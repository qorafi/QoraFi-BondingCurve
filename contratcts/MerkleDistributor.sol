// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol";

// You'll need the same IXYZToken interface from your other contracts
interface IXYZToken {
    function mint(address to, uint256 amount) external;
}

/**
 * @title MerkleDistributor
 * @dev Distributes XYZ tokens to users based on an off-chain generated Merkle tree.
 */
contract MerkleDistributor is Ownable {
    IXYZToken public immutable xyzToken;
    bytes32 public merkleRoot;

    // This mapping is a gas-efficient way to track claims.
    // Each bit in the uint256 represents a claimed index.
    mapping(uint256 => uint256) private claimedBitMap;

    event MerkleRootUpdated(bytes32 newRoot);
    event Claimed(uint256 index, address account, uint256 amount);

    error InvalidProof();
    error AlreadyClaimed();

    constructor(address _xyzTokenAddress) Ownable(msg.sender) {
        xyzToken = IXYZToken(_xyzTokenAddress);
    }

    /**
     * @notice Allows the owner to set the Merkle root for a new reward period.
     */
    function setMerkleRoot(bytes32 _merkleRoot) public onlyOwner {
        merkleRoot = _merkleRoot;
        emit MerkleRootUpdated(_merkleRoot);
    }

    /**
     * @notice Allows a user to claim their rewards by providing a Merkle proof.
     * @param index The user's index in the off-chain rewards list.
     * @param account The user's address.
     * @param amount The reward amount in XYZ tokens.
     * @param merkleProof The proof generated by the server to validate the claim.
     */
    function claim(
        uint256 index,
        address account,
        uint256 amount,
        bytes32[] calldata merkleProof
    ) public {
        if (isClaimed(index)) revert AlreadyClaimed();

        // 1. Recreate the leaf hash on-chain
        bytes32 leaf = keccak256(abi.encodePacked(index, account, amount));

        // 2. Verify the leaf against the stored root using the proof
        if (!MerkleProof.verify(merkleProof, merkleRoot, leaf)) {
            revert InvalidProof();
        }

        // 3. Mark the claim as processed
        _setClaimed(index);

        // 4. Mint the rewards
        xyzToken.mint(account, amount);
        emit Claimed(index, account, amount);
    }

    // --- Helper functions for tracking claims ---

    function _setClaimed(uint256 index) private {
        uint256 bitmapIndex = index / 256;
        uint256 bit = 1 << (index % 256);
        claimedBitMap[bitmapIndex] |= bit;
    }

    function isClaimed(uint256 index) public view returns (bool) {
        uint256 bitmapIndex = index / 256;
        uint256 bit = 1 << (index % 256);
        return (claimedBitMap[bitmapIndex] & bit) != 0;
    }
}